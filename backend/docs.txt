This code sets up an Express application that handles payment confirmations, performs transaction verification with Flutterwave, updates a transaction record in a database, and sends a confirmation email with details about the user's purchased plans. Here’s an overview of the flow:

### 1. **Environment Setup**
   - The code begins by loading environment variables using `dotenv` (`require('dotenv').config()`).
   - Several libraries are imported, including:
     - `express`: Framework to handle routing and requests.
     - `body-parser`: For parsing incoming JSON data.
     - `cors`: Middleware to enable Cross-Origin Resource Sharing (CORS).
     - `axios`: For making HTTP requests, used for verifying payment via the Flutterwave API.
     - `nodemailer`: For sending emails to users.
     - `winston`: For logging.
     - `rateLimit`: To prevent abuse by limiting the number of requests from a single IP.
     - `sequelize`: ORM for interacting with the database.
     - `Transaction`, `Plan`, and `Code`: Models to interact with the database tables related to transactions, subscription plans, and codes.
     - `sendEmail`: A custom email sending service.

### 2. **Middleware**
   - A rate limiter is set up to allow a maximum of 100 requests per IP every 15 minutes using `express-rate-limit`.
   - CORS is enabled for a specific origin (`http://localhost:5173`), and requests are allowed only for the `GET` and `POST` methods.
   - `bodyParser.json()` is used to parse incoming JSON data in requests.

### 3. **Database Connection**
   - The app establishes a connection to the database using `sequelize.authenticate()`.
   - Once connected, it synchronizes the models with the database using `sequelize.sync()`.

### 4. **Payment Confirmation Endpoint (`/payment-confirmation`)**
   - This endpoint receives a `POST` request with details about the payment, including the transaction reference (`tx_ref`), customer email, plans purchased, transaction type, amount, and customer name.
   - **Validation**: It checks whether all required fields (`tx_ref`, `customerEmail`, `plans`, `type`, `amount`, `customerName`) are present in the request body. If any are missing, it returns a `400` status with an error message.

### 5. **Creating Transaction Record**
   - If the data is valid, a new transaction is created in the database with a `status` set to `0` (Pending).
   - The transaction includes customer email, transaction reference, amount, and name.

### 6. **Verifying Payment with Flutterwave**
   - A function (`verifyTransaction`) is called to verify the payment via the Flutterwave API using the `tx_ref` from the request.
   - The `verifyTransaction` function sends a `GET` request to the Flutterwave API using the `tx_ref` and the secret API key (`flutterwaveKey`) to retrieve the payment status.
   - If the payment is successful (i.e., the verification response indicates success), the transaction status is updated to `1` (Success), and the Flutterwave reference is stored.
   - If the payment is not successful, the transaction status is set to `2` (Failed), and the process ends with a `400` error response.

### 7. **Handling Reseller Case**
   - If the `type` of the transaction is `"reseller"`, the system retrieves the plans purchased by the user, checks if the requested quantity of codes is available, and then:
     - Fetches available codes for the specified plans from the database.
     - Decrypts the codes using a `decrypt` function.
     - Marks the redeemed codes as used in the database (sets `isRedeemed` to `true`).
     - Prepares an email with details about the purchased plans and their corresponding codes.

### 8. **Sending Confirmation Email**
   - After preparing the email content, the app attempts to send an email to the customer using the externalized `sendEmail` function.
   - If sending the email fails, it logs the error and returns a `500` status with a failure message.
   - If the email is sent successfully, it logs a success message.

### 9. **Error Handling**
   - If any error occurs during the process (e.g., transaction creation, plan fetching, or email sending), it is logged using the `winston` logger, and a `500` response is returned with the error message.

### 10. **Transaction Verification Function**
   - The `verifyTransaction` function makes an API request to Flutterwave’s verification endpoint using the transaction reference (`tx_ref`) and the secret API key.
   - If the verification is successful, the response will contain a success status, and if not, it returns a failure status.

### 11. **Server Setup**
   - Finally, the app starts a server and listens on the defined port (`PORT`), which defaults to 3000.

---

### Flow Summary:
1. The customer makes a payment.
2. The payment data is sent to the `/payment-confirmation` endpoint.
3. The transaction is created with status `0` (Pending).
4. The payment is verified with Flutterwave.
5. If the payment is successful:
   - Plans are processed, codes are redeemed, and an email with codes is sent.
6. The transaction status is updated to `1` (Success), or `2` (Failed) if the verification fails.
7. Logs are created for all important steps and errors.

This flow ensures that the backend securely handles payment verification, transaction recording, and code assignment, while also providing timely feedback to the customer through email.





import { useLocation, useNavigate } from 'react-router-dom'; // Import useNavigate
import { useEffect, useState } from 'react';
import useScript from '../hooks/useScript'; // Import the custom hook
import axios from 'axios';

const generateReference = () => {
	const chars =
		'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
	let reference = '';
	for (let i = 0; i < 10; i++) {
		reference += chars.charAt(Math.floor(Math.random() * chars.length));
	}
	return reference;
};

const CompleteTransaction = () => {
	const location = useLocation();
	const navigate = useNavigate(); // Initialize the navigate hook
	const { hasLoaded, hasError } = useScript(
		'https://checkout.flutterwave.com/v3.js'
	);
	const [isProcessing, setIsProcessing] = useState(false); // State for tracking payment processing status
	const [errorMessage, setErrorMessage] = useState(''); // State for error handling
	const [isLoading, setIsLoading] = useState(true); // State to handle script loading state

	useEffect(() => {
		if (hasLoaded) {
			setIsLoading(false);
			console.log('Flutterwave script has loaded');
		} else if (hasError) {
			setIsLoading(false);
			setErrorMessage(
				'Error loading Flutterwave script. Please try again later.'
			);
			console.log('Error loading Flutterwave script');
		}
	}, [hasLoaded, hasError]);

	const { name, email, plan } = location.state || {};
	const reference = generateReference();

	const validatePlan = () => {
		if (!plan || !plan.name || !plan.price) {
			setErrorMessage('Invalid plan data. Please try again.');
			return false;
		}
		return true;
	};

	const handlePayment = (e) => {
		e.preventDefault();

		if (!window.FlutterwaveCheckout) {
			alert('Flutterwave script is not loaded. Please try again later.');
			return;
		}

		// Validate plan data
		if (!validatePlan()) return;

		const amount = plan.price || 0;

		setIsProcessing(true); // Mark as processing
		window.FlutterwaveCheckout({
			public_key: 'FLWPUBK_TEST-6307e10c1faf0f32c15ab623ed6a67cc-X', // Replace with your test public key
			tx_ref: reference,
			amount: amount,
			currency: 'NGN',
			payment_options: 'card, mobilemoney, ussd',
			customer: {
				email: email || 'noemail@example.com',
				phonenumber: '', // Optional: Add phone number here
				name: name || 'Unknown User',
			},
			customizations: {
				title: 'Reseller Payment',
				description: `Payment for ${plan?.name || 'selected plan'}`,
				logo: 'https://your-logo-url.com/logo.png', // Optional: Add your logo URL
			},
			callback: (data) => {
				console.log('Payment successful:', data);
				alert('Payment Successful!');

				// Send type 'subscribe' to the backend when the payment is successful
				const transactionData = {
					tx_ref: reference,
					customerEmail: email,
					plans: [plan],
					type: 'subscribe', // Add the type here
					amount: amount,
					customerName: name,
				};

				// Make the backend API call
				handleBackendAPI(transactionData);

				// Navigate to homepage after successful payment
				navigate('/'); // Redirect to homepage
			},
			onclose: () => {
				console.log('Payment closed');
				alert('Payment was not completed.');
				setIsProcessing(false); // Reset processing state
			},
		});
	};

	// Separate function to handle backend API call
	const handleBackendAPI = (transactionData) => {
		axios
			.post('http://localhost:3000/payment-confirmation', transactionData)
			.then((response) => {
				console.log('Transaction processed successfully:', response.data);
				setIsProcessing(false); // Reset processing state
			})
			.catch((error) => {
				console.error('Error processing transaction:', error);
				setErrorMessage('Transaction failed. Please try again later.');
				setIsProcessing(false); // Reset processing state
			});
	};

	return (
		<div className='transaction-details-container'>
			<h1>Transaction Details</h1>

			<form className='subscribe-form' onSubmit={handlePayment}>
				<h1>Get Started</h1>
				<p>
					Please feel free to reach out to us for any complaints{' '}
					<span>support@saptav.ng</span> | <span>+234 802 916 1107</span>
				</p>
				<p>
					Please take note of this reference: <strong>{reference}</strong>. Use
					this to contact us for any issues related to this transaction.
				</p>

				{isLoading && <p>Loading payment system...</p>}
				{errorMessage && <p className='error-message'>{errorMessage}</p>}

				<div className='transaction-details'>
					<h3>
						<u>Transaction Details</u>
					</h3>
					<div className='transaction-row'>
						<p className='transaction-key'>Name: {name || 'N/A'}</p>
					</div>
					<div className='transaction-row'>
						<p className='transaction-key'>Email: {email || 'N/A'}</p>
					</div>
					<div className='transaction-row'>
						<p className='transaction-key'>Reference: {reference}</p>
					</div>
					{plan && (
						<p>
							You subscribed to the <strong>{plan.name}</strong> plan for ₦
							<strong>{plan.price}</strong>.
						</p>
					)}
				</div>
				<button
					type='submit'
					className='button'
					disabled={isProcessing} // Disable the button during payment processing
				>
					{isProcessing ? 'Processing...' : 'Pay Now'}
				</button>
			</form>
		</div>
	);
};

export default CompleteTransaction;

the complete payment page is when users want to purchase a single code and the complete payment page takes them to flutterwave to make their payment after which the backend verifies the transactions, decrypt a code and send to them via the mail they provided in the front end and then the backend logs the transaction in the Transactions table in the database.